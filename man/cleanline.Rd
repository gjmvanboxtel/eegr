% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cleanline.R
\name{cleanline}
\alias{cleanline}
\title{Cleanline}
\usage{
cleanline(
  x,
  fs = 1,
  lfreq = 50,
  fbw = 2,
  detrend = c("short-linear", "short-mean", "long-linear", "long-mean", "none"),
  w = 4,
  overlap = 0,
  tbw = 2,
  k = round(tbw * w - 1),
  p = 0.01,
  tau = 100,
  maxIter = 10
)
}
\arguments{
\item{x}{input time series, specified as a numeric or complex or matrix
vector. In case of a vector it represents a single signal; in case of a
matrix each column is a signal. Alternatively, an object of class
\code{\link{ctd}}}

\item{fs}{sampling frequency of \code{x} in Hz. Default: 1. Overruled if
\code{x} is a \code{ctd} object, in which case the sampling frequency is
\code{fs(x)}}

\item{lfreq}{line frequencies to remove, either specified as a single numeric
value, or as a character string. If a single numeric value is specified,
then this value will be expanded to include multiples of that frequency
(harmonics) up to the Nyquist frequency. If a character string is
specified, then the string will be converted to numeric values without
further expansion. Default: 50}

\item{fbw}{frequency bandwidth. Bandwidth centered on each \code{lfreq} to
scan for significant lines. Default: 2 Hz.}

\item{detrend}{character string specifying detrending option; one of:
 \describe{
   \item{\code{short-linear}}{remove the mean from the data before
   splitting into segments (default)}
   \item{\code{short-mean}}{remove the mean value of each segment}
   \item{\code{long-linear}}{remove linear trend from the data before
   splitting into segments}
   \item{\code{long-mean}}{remove linear trend from each segment}
   \item{\code{none}}{no detrending}
}
Specifying one of the \code{long} forms will result in detrended cleaned
data. By contrast, specifying one the of \code{short} forms will perform the
calculations on detrended segments but this will not affect the returned
data.}

\item{w}{length of sliding window (segments) in seconds. Default: 4}

\item{overlap}{proportion of overlap between the segments. Default: 0}

\item{tbw}{taper bandwidth, specified as a positive numeric value. Default: 2
Hz}

\item{k}{number of tapers to use, specified as a positive numeric value.
Default: \code{tbw * w - 1}}

\item{p}{significance level cutoff for F-test. Default 0.01}

\item{tau}{Window overlap smoothing factor. Default: 100}

\item{maxIter}{Maximum times to iterate removal. Default: 10}
}
\value{
A list consiting of 3 elements:
  \describe{
    \item{\code{y}}{the cleaned data}
    \item{\code{lfreq}}{the cleaned line frequencies}
    \item{\code{niter}}{the number of iterations executed}
  }
}
\description{
Estimate and remove sinusoidal (e.g. line) noise from EEG  channels using
multi-tapering and a Thompson F-statistic.
}
\details{
Sinusoidal noise can be a prominent artifact in recorded electrophysiological
data. This can stem from AC power line fluctuations (e.g. 50/60 Hz line noise
+ harmonics), power suppliers (e.g. in medical equipment), fluorescent
lights, etc. Notch filtering is generally undesirable due to creation of
band-holes, and significant distortion of frequencies around the notch
frequency (as well as phase distortion at other frequencies and Gibbs
rippling in the time-domain). Other approaches for sinusoidal ("line") noise
reduction include adaptive regressive filtering approaches (e.g. RLS, LMS),
but these typically require a reference signal (e.g. externally-recorded
noise reference), which is often unavailable. Blind-source separation
approaches such as ICA may help mitigate line noise, but often fail to
completely remove the noise due to spatiotemporal non-stationarities in the
noise.

CleanLine uses an approach for line noise removal advocated by Partha Mitra
and Hemant Bokil in "Observed Brain Dynamics" (2007), Chapter 7.3.4.

In brief, the data is traversed by a sliding window. Within each window, the
signal is transformed to the frequency domain using a multi-taper FFT. The
complex amplitude (amplitude and phase) is thus obtained for each frequency.
Under the assumption of a deterministic sinusoid embedded in white noise, we
can set up a regression of the multi-taper transform (spectrum) of this
sinusoidal signal onto the multitaper spectrum of the original data at a
given frequency. The regression coefficient is a complex number representing
the complex amplitude (phase and amplitude) of the deterministic sinusoid.
From this, a time-domain representation of the sinusoid may be constructed
and subtracted from the data to remove the line.

Typically, one does not know the exact line frequency. For instance, in the
U.S.A., power line noise is not guaranteed to be at exactly 60 Hz (or even to
have constant phase over a given period of time). To ameliorate this problem
a Thompson F-Test may be applied to determine the statistical significance of
a non-zero coefficient in the above regression (indicating a sinusoid with
significantly non-zero amplitude). We can then search within a narrow band
around the expected location of the line for the frequency which maximizes
this F-statistic above a significance threshold (e.g. p=0.05).

Overlapping short (e.g. 2-4 second) windows can be used to adaptively
estimate the frequency, phase, and amplitude of the sinusoidal noise
components (which typically change over the course of a recording session).
The discontinuity at the point of window overlap can be smoothed using a
sigmoidal function.
}
\examples{
data(EEGdata)
ospec <- mtspec(EEGdata[, 1:28], fs = fs(EEGdata), detrend = "short-linear")
cleaned <- cleanline(EEGdata[, 1:28], fs = fs(EEGdata))
cspec <- mtspec(cleaned$y, fs = fs(EEGdata), detrend = "short-linear")
plot(ospec[, "f"], 10 * log10(ospec[, "Pz"]), type = "l",
      main = "Multitaper Spectrum\nEEGdata - Pz",
      xlab = "Frequency (Hz)", ylab = "Power/Frequency (dB)")
lines(cspec[, "f"], 10 * log10(cspec[, "Pz"]), col = "red")
legend("topright", legend = c("Original", "Cleaned"), lty = 1,
       col = c("black", "red"))
}
\seealso{
\code{\link{mtspec}}
}
\author{
Original Matlab code by Tim Mullen (2011); ported to R and
  adapted by Geert van Boxtel, \email{G.J.M.vanBoxtel@gmail.com},
}
